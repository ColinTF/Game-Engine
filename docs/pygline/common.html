<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygline.common API documentation</title>
<meta name="description" content="Common classes and stuctures used through out the whole package" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygline.common</code></h1>
</header>
<section id="section-intro">
<p>Common classes and stuctures used through out the whole package</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Common classes and stuctures used through out the whole package
&#34;&#34;&#34;

from collections.abc import Sequence
import numpy as np
    

class Vertex:
    &#34;&#34;&#34;

    # VERTEX

    The vertex class is a fundemental, versatille and easy to use class containing positional and color data.
    The data is stored as x,y,z,r,g,b attributes. However the data can be accessed and modified in a variety of ways.

    Attributes:
        - `x`,`y`,`z` : `np.float32` - 3d coordinates of vertex
        - `r`,`g`,`b` : `np.float32` - color of vertex

    Methods:
        - `copy()` -&gt; `Vertex` - returns a copy of the vertex
        - `get_magnitude()` -&gt; `np.float32` - returns the magnitude of the vertex
        - `get_brightness()` -&gt; `np.float32` - returns the brightness of the vertex
        - `normalize()` -&gt; `None` - normalizes the vertex to a unit vector

    ---

    ## Usage

    Groups of vertices are used to define objects through the Mesh Class and what color they should be.
    Use the `vert.xyz` or `vert.rgb` or variants like `vert.zxy` and `vert.xyrg` to use the data as a numpy array in the order of the attributes.
    Use the `vert.coords` or `vert.color` to get the just the positional or color data as a numpy array. The functionality is designed to be very flexible however,
    the user should be familiar with how the class works. Comparison and math operations only affect the positional data and behave similarly to assignment

    Operations:
        - `==` : compares the `x`,`y`,`z` values element wise
        - `&lt;`,`&gt;` : compares the `magnitude()` of the vertex
        - `+`,`-`,`*`,`/` : acts accordingly based on the type of the other object
            - if other is a Vertex : acts element wise
            - if other is a array : acts element wise for values that exist in array
            - if other is a number : acts on all `x`,`y`,`z` values

    ---

    ## Notes

    All values are stored a numpy float32 which hold 32 bits or 4 bytes of data. This is helpful to know the exact size for createing vertex buffers.
    &#34;&#34;&#34;

    variables = &#39;xyzrgb&#39;
    &#34;&#34;&#34;All the variable a Vertex should hold, like __dict__ but as string&#34;&#34;&#34;

    one = np.float32(1.0)
    &#34;&#34;&#34;1.0 as a numpy float32&#34;&#34;&#34;
    zero = np.float32(0.0)
    &#34;&#34;&#34;0.0 as a numpy float32&#34;&#34;&#34;

    def __init__(self, *args, default : np.float32 = zero, **kwargs):
        &#34;&#34;&#34;
        Create a vertex with 3d coordinates and rgb colors.
        Can pass a Squence like object or a numpy array as the input parmaters as well.

        Args:
            - x,y,z,r,g,b : np.float32 values in order, pass as many values as needed the rest will be set to 0.0
            if one value is passed it will be used for all 3d coordinates and color will be set to 0.0

        Keyword Args:
            - x,y,z,r,g,b : np.float32 values in any order, overrides already set values by the args
            - default : np.float32 value to use if no value is passed
        &#34;&#34;&#34;

        # If the input is a sequence take the sequence as the args
        if isinstance(args[0], (Sequence, np.ndarray)):
            args = args[0]

        args_length = len(args)

        # If one args is passed set it to only the coordinates
        if args_length == 1:
            args = [args[0]]*3
            args_length = len(args)

        # Make sure the default is a numpy float32
        default = np.float32(default)

        # Set x,y,z values if the args exist else set them to 0
        self.x : np.float32 = np.float32(args[0]) if args_length &gt;= 1 else default
        &#34;&#34;&#34;X postion as a float&#34;&#34;&#34;
        self.y : np.float32 = np.float32(args[1]) if args_length &gt;= 2 else default
        &#34;&#34;&#34;Y postion as a float&#34;&#34;&#34;
        self.z : np.float32 = np.float32(args[2]) if args_length &gt;= 3 else default
        &#34;&#34;&#34;Z postion as a flo  at&#34;&#34;&#34;

        # Set r,g,b values if the args exists else set them to 0
        self.r : np.float32 = np.float32(args[3]) if args_length &gt;= 4 else default
        &#34;&#34;&#34;Red value as a float&#34;&#34;&#34;
        self.g : np.float32 = np.float32(args[4]) if args_length &gt;= 5 else default
        &#34;&#34;&#34;Green value as a float&#34;&#34;&#34;
        self.b : np.float32 = np.float32(args[5]) if args_length &gt;= 6 else default
        &#34;&#34;&#34;Blue value as a float&#34;&#34;&#34;

        # Use keyword args to override the values
        for key, value in kwargs.items():
            if key in self.variables:
                self.__dict__[key] = np.float32(value)
            else:
                raise AttributeError(key)

    def copy(self):
        &#34;&#34;&#34;Retuns a copy of the vertex&#34;&#34;&#34;
        return Vertex(self.x, self.y, self.z, self.r, self.g, self.b)

    def get_magnitude(self):
        &#34;&#34;&#34;Returns the magnitude of the vertex&#34;&#34;&#34;
        return np.sqrt(self.x**2 + self.y**2 + self.z**2)

    def get_brightness(self):
        &#34;&#34;&#34;Returns the brightness of the vertex&#34;&#34;&#34;
        return np.sqrt(self.r**2 + self.g**2 + self.b**2)

    def normalize(self):
        &#34;&#34;&#34;Normalizes the vertex to a unit vector&#34;&#34;&#34;
        mag = self.magnitude()
        if mag != 0.0:
            self.x /= mag
            self.y /= mag
            self.z /= mag

    def normalize_color(self):
        &#34;&#34;&#34;Normalize the color to a unit vector&#34;&#34;&#34;
        mag = self.brightness()
        if mag != 0.0:
            self.r /= mag
            self.g /= mag
            self.b /= mag

    def __getattr__(self, items : str):
        &#34;&#34;&#34;Lets us retrive any values in any order as a numpy array&#34;&#34;&#34;
        if items == &#39;coords&#39;:
            return np.array([self.x, self.y, self.z], dtype=np.float32)
        elif items == &#39;color&#39;:
            return np.array([self.r, self.g, self.b], dtype=np.float32)
        else:
            # Then its something like xyz, or xy or yzr - in short any combination of x y z / r g b
            attributes = np.zeros(len(items), dtype=np.float32)
            for i, item in enumerate(items):
                if item in self.variables:
                    attributes[i] = self.__dict__[item]
                else:
                    raise AttributeError(item)
            return attributes

    def _set_values(self, items : str, inp):
        &#34;&#34;&#34;For internal use - assign values directly with &#34;vert.xyz = (0.1, 0.2, 0.3)&#34; instead&#34;&#34;&#34;
        if isinstance(inp, (Sequence, np.ndarray)):
            # the input is a sequence
            for i, item in enumerate(items):
                if i &lt; len(inp) and item in self.variables:
                    self.__dict__[item] = np.float32(inp[i])
        else:
            # The input is a single value
            for i, item in enumerate(items):
                if item in self.variables:
                    self.__dict__[item] = np.float32(inp)

    def __setattr__(self, items : str, inp):
        &#34;&#34;&#34;Set values of the vertex. For example `[vert.xyz | vert.x | vert.rxyb] = ... ` are all valid&#34;&#34;&#34;
        # Set some aliases
        if items == &#39;coords&#39;:
            self._set_values(&#39;xyz&#39;, inp)
        elif items == &#39;color&#39;:
            self._set_values(&#39;rgb&#39;, inp)
        else:
            # Is it a list of inputs like xyz, or xy or yzr? - in short any combination of x y z / r g b 
            self._set_values(items, inp)

    # create math methods for the vertex class
    def __add__(self, other):
        &#34;&#34;&#34;Add other to self only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x + other.x, self.y + other.y, self.z + other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other)
            return self.__add__(vert2)
        else:
            return Vertex(self.x + other, self.y + other, self.z + other, self.r, self.g, self.b)
    
    def __radd__(self, other):
        &#34;&#34;&#34;Add other to self only considering positional data&#34;&#34;&#34;
        return self.__add__(other)

    def __sub__(self, other):
        &#34;&#34;&#34;Subtract other from self only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x - other.x, self.y - other.y, self.z - other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other)
            return self.__sub__(vert2)
        else:
            return Vertex(self.x - other, self.y - other, self.z - other, self.r, self.g, self.b)

    def __rsub__(self, other):
        &#34;&#34;&#34;Subtract other from self only considering positional data&#34;&#34;&#34;
        return self.__sub__(other)

    def __mul__(self, other):
        &#34;&#34;&#34;Multiply self by other only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x * other.x, self.y * other.y, self.z * other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other, default=1.0)
            return self.__mul__(vert2)
        else:
            return Vertex(self.x * other, self.y * other, self.z * other, self.r, self.g, self.b)

    def __rmul__(self, other):
        &#34;&#34;&#34;Multiply self by other only considering positional data&#34;&#34;&#34;
        return self.__mul__(other)

    def __div__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x / other.x, self.y / other.y, self.z / other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other, default=1.0)
            return self.__div__(vert2)
        else:
            return Vertex(self.x / other, self.y / other, self.z / other, self.r, self.g, self.b)

    def __rdiv__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        return self.__div__(other)

    # true div use div for now
    def __truediv__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        return self.__div__(other)

    def __rtruediv__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        return self.__rdiv__(other)


    # Define comparison operators
    def __eq__(self, other):
        &#34;&#34;&#34;Equality operator for only positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return self.x == other.x and self.y == other.y and self.z == other.z
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex call again
            vert2 = Vertex(other)
            return self.__eq__(vert2)
        else:
            return self.x == other and self.y == other and self.z == other

    # Less then and greater then operators based on magnitude
    def __lt__(self, other):
        &#34;&#34;&#34;Less than operator for only positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return self.magnitude() &lt; other.magnitude()
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex call again
            vert2 = Vertex(other)
            return self.__lt__(vert2)
        else:
            return self.magnitude() &lt; other

    def __gt__(self, other):
        &#34;&#34;&#34;Greater than operator for only positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return self.magnitude() &gt; other.magnitude()
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex call again
            vert2 = Vertex(other)
            return self.__gt__(vert2)
        else:
            return self.magnitude() &gt; other

    def __le__(self, other):
        return self.__lt__(other) or self.__eq__(other)

    def __ge__(self, other):
        return self.__gt__(other) or self.__eq__(other)

    def __repr__(self):
        return f&#39;Vertex({self.x}, {self.y}, {self.z}, {self.r}, {self.g}, {self.b})&#39;

    # TODO add __str__</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygline.common.Vertex"><code class="flex name class">
<span>class <span class="ident">Vertex</span></span>
<span>(</span><span>*args, default: numpy.float32 = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="vertex">VERTEX</h1>
<p>The vertex class is a fundemental, versatille and easy to use class containing positional and color data.
The data is stored as x,y,z,r,g,b attributes. However the data can be accessed and modified in a variety of ways.</p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>x</code>,<code>y</code>,<code>z</code> : <code>np.float32</code> - 3d coordinates of vertex</li>
<li><code>r</code>,<code>g</code>,<code>b</code> : <code>np.float32</code> - color of vertex</li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li><code>copy()</code> -&gt; <code><a title="pygline.common.Vertex" href="#pygline.common.Vertex">Vertex</a></code> - returns a copy of the vertex</li>
<li><code>get_magnitude()</code> -&gt; <code>np.float32</code> - returns the magnitude of the vertex</li>
<li><code>get_brightness()</code> -&gt; <code>np.float32</code> - returns the brightness of the vertex</li>
<li><code>normalize()</code> -&gt; <code>None</code> - normalizes the vertex to a unit vector</li>
</ul>
<hr>
<h2 id="usage">Usage</h2>
<p>Groups of vertices are used to define objects through the Mesh Class and what color they should be.
Use the <code>vert.xyz</code> or <code>vert.rgb</code> or variants like <code>vert.zxy</code> and <code>vert.xyrg</code> to use the data as a numpy array in the order of the attributes.
Use the <code>vert.coords</code> or <code>vert.color</code> to get the just the positional or color data as a numpy array. The functionality is designed to be very flexible however,
the user should be familiar with how the class works. Comparison and math operations only affect the positional data and behave similarly to assignment</p>
<h2 id="operations">Operations</h2>
<ul>
<li><code>==</code> : compares the <code>x</code>,<code>y</code>,<code>z</code> values element wise</li>
<li><code>&lt;</code>,<code>&gt;</code> : compares the <code>magnitude()</code> of the vertex</li>
<li><code>+</code>,<code>-</code>,<code>*</code>,<code>/</code> : acts accordingly based on the type of the other object<ul>
<li>if other is a Vertex : acts element wise</li>
<li>if other is a array : acts element wise for values that exist in array</li>
<li>if other is a number : acts on all <code>x</code>,<code>y</code>,<code>z</code> values</li>
</ul>
</li>
</ul>
<hr>
<h2 id="notes">Notes</h2>
<p>All values are stored a numpy float32 which hold 32 bits or 4 bytes of data. This is helpful to know the exact size for createing vertex buffers.</p>
<p>Create a vertex with 3d coordinates and rgb colors.
Can pass a Squence like object or a numpy array as the input parmaters as well.</p>
<h2 id="args">Args</h2>
<ul>
<li>x,y,z,r,g,b : np.float32 values in order, pass as many values as needed the rest will be set to 0.0
if one value is passed it will be used for all 3d coordinates and color will be set to 0.0
Keyword Args:<ul>
<li>x,y,z,r,g,b : np.float32 values in any order, overrides already set values by the args</li>
<li>default : np.float32 value to use if no value is passed</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vertex:
    &#34;&#34;&#34;

    # VERTEX

    The vertex class is a fundemental, versatille and easy to use class containing positional and color data.
    The data is stored as x,y,z,r,g,b attributes. However the data can be accessed and modified in a variety of ways.

    Attributes:
        - `x`,`y`,`z` : `np.float32` - 3d coordinates of vertex
        - `r`,`g`,`b` : `np.float32` - color of vertex

    Methods:
        - `copy()` -&gt; `Vertex` - returns a copy of the vertex
        - `get_magnitude()` -&gt; `np.float32` - returns the magnitude of the vertex
        - `get_brightness()` -&gt; `np.float32` - returns the brightness of the vertex
        - `normalize()` -&gt; `None` - normalizes the vertex to a unit vector

    ---

    ## Usage

    Groups of vertices are used to define objects through the Mesh Class and what color they should be.
    Use the `vert.xyz` or `vert.rgb` or variants like `vert.zxy` and `vert.xyrg` to use the data as a numpy array in the order of the attributes.
    Use the `vert.coords` or `vert.color` to get the just the positional or color data as a numpy array. The functionality is designed to be very flexible however,
    the user should be familiar with how the class works. Comparison and math operations only affect the positional data and behave similarly to assignment

    Operations:
        - `==` : compares the `x`,`y`,`z` values element wise
        - `&lt;`,`&gt;` : compares the `magnitude()` of the vertex
        - `+`,`-`,`*`,`/` : acts accordingly based on the type of the other object
            - if other is a Vertex : acts element wise
            - if other is a array : acts element wise for values that exist in array
            - if other is a number : acts on all `x`,`y`,`z` values

    ---

    ## Notes

    All values are stored a numpy float32 which hold 32 bits or 4 bytes of data. This is helpful to know the exact size for createing vertex buffers.
    &#34;&#34;&#34;

    variables = &#39;xyzrgb&#39;
    &#34;&#34;&#34;All the variable a Vertex should hold, like __dict__ but as string&#34;&#34;&#34;

    one = np.float32(1.0)
    &#34;&#34;&#34;1.0 as a numpy float32&#34;&#34;&#34;
    zero = np.float32(0.0)
    &#34;&#34;&#34;0.0 as a numpy float32&#34;&#34;&#34;

    def __init__(self, *args, default : np.float32 = zero, **kwargs):
        &#34;&#34;&#34;
        Create a vertex with 3d coordinates and rgb colors.
        Can pass a Squence like object or a numpy array as the input parmaters as well.

        Args:
            - x,y,z,r,g,b : np.float32 values in order, pass as many values as needed the rest will be set to 0.0
            if one value is passed it will be used for all 3d coordinates and color will be set to 0.0

        Keyword Args:
            - x,y,z,r,g,b : np.float32 values in any order, overrides already set values by the args
            - default : np.float32 value to use if no value is passed
        &#34;&#34;&#34;

        # If the input is a sequence take the sequence as the args
        if isinstance(args[0], (Sequence, np.ndarray)):
            args = args[0]

        args_length = len(args)

        # If one args is passed set it to only the coordinates
        if args_length == 1:
            args = [args[0]]*3
            args_length = len(args)

        # Make sure the default is a numpy float32
        default = np.float32(default)

        # Set x,y,z values if the args exist else set them to 0
        self.x : np.float32 = np.float32(args[0]) if args_length &gt;= 1 else default
        &#34;&#34;&#34;X postion as a float&#34;&#34;&#34;
        self.y : np.float32 = np.float32(args[1]) if args_length &gt;= 2 else default
        &#34;&#34;&#34;Y postion as a float&#34;&#34;&#34;
        self.z : np.float32 = np.float32(args[2]) if args_length &gt;= 3 else default
        &#34;&#34;&#34;Z postion as a flo  at&#34;&#34;&#34;

        # Set r,g,b values if the args exists else set them to 0
        self.r : np.float32 = np.float32(args[3]) if args_length &gt;= 4 else default
        &#34;&#34;&#34;Red value as a float&#34;&#34;&#34;
        self.g : np.float32 = np.float32(args[4]) if args_length &gt;= 5 else default
        &#34;&#34;&#34;Green value as a float&#34;&#34;&#34;
        self.b : np.float32 = np.float32(args[5]) if args_length &gt;= 6 else default
        &#34;&#34;&#34;Blue value as a float&#34;&#34;&#34;

        # Use keyword args to override the values
        for key, value in kwargs.items():
            if key in self.variables:
                self.__dict__[key] = np.float32(value)
            else:
                raise AttributeError(key)

    def copy(self):
        &#34;&#34;&#34;Retuns a copy of the vertex&#34;&#34;&#34;
        return Vertex(self.x, self.y, self.z, self.r, self.g, self.b)

    def get_magnitude(self):
        &#34;&#34;&#34;Returns the magnitude of the vertex&#34;&#34;&#34;
        return np.sqrt(self.x**2 + self.y**2 + self.z**2)

    def get_brightness(self):
        &#34;&#34;&#34;Returns the brightness of the vertex&#34;&#34;&#34;
        return np.sqrt(self.r**2 + self.g**2 + self.b**2)

    def normalize(self):
        &#34;&#34;&#34;Normalizes the vertex to a unit vector&#34;&#34;&#34;
        mag = self.magnitude()
        if mag != 0.0:
            self.x /= mag
            self.y /= mag
            self.z /= mag

    def normalize_color(self):
        &#34;&#34;&#34;Normalize the color to a unit vector&#34;&#34;&#34;
        mag = self.brightness()
        if mag != 0.0:
            self.r /= mag
            self.g /= mag
            self.b /= mag

    def __getattr__(self, items : str):
        &#34;&#34;&#34;Lets us retrive any values in any order as a numpy array&#34;&#34;&#34;
        if items == &#39;coords&#39;:
            return np.array([self.x, self.y, self.z], dtype=np.float32)
        elif items == &#39;color&#39;:
            return np.array([self.r, self.g, self.b], dtype=np.float32)
        else:
            # Then its something like xyz, or xy or yzr - in short any combination of x y z / r g b
            attributes = np.zeros(len(items), dtype=np.float32)
            for i, item in enumerate(items):
                if item in self.variables:
                    attributes[i] = self.__dict__[item]
                else:
                    raise AttributeError(item)
            return attributes

    def _set_values(self, items : str, inp):
        &#34;&#34;&#34;For internal use - assign values directly with &#34;vert.xyz = (0.1, 0.2, 0.3)&#34; instead&#34;&#34;&#34;
        if isinstance(inp, (Sequence, np.ndarray)):
            # the input is a sequence
            for i, item in enumerate(items):
                if i &lt; len(inp) and item in self.variables:
                    self.__dict__[item] = np.float32(inp[i])
        else:
            # The input is a single value
            for i, item in enumerate(items):
                if item in self.variables:
                    self.__dict__[item] = np.float32(inp)

    def __setattr__(self, items : str, inp):
        &#34;&#34;&#34;Set values of the vertex. For example `[vert.xyz | vert.x | vert.rxyb] = ... ` are all valid&#34;&#34;&#34;
        # Set some aliases
        if items == &#39;coords&#39;:
            self._set_values(&#39;xyz&#39;, inp)
        elif items == &#39;color&#39;:
            self._set_values(&#39;rgb&#39;, inp)
        else:
            # Is it a list of inputs like xyz, or xy or yzr? - in short any combination of x y z / r g b 
            self._set_values(items, inp)

    # create math methods for the vertex class
    def __add__(self, other):
        &#34;&#34;&#34;Add other to self only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x + other.x, self.y + other.y, self.z + other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other)
            return self.__add__(vert2)
        else:
            return Vertex(self.x + other, self.y + other, self.z + other, self.r, self.g, self.b)
    
    def __radd__(self, other):
        &#34;&#34;&#34;Add other to self only considering positional data&#34;&#34;&#34;
        return self.__add__(other)

    def __sub__(self, other):
        &#34;&#34;&#34;Subtract other from self only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x - other.x, self.y - other.y, self.z - other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other)
            return self.__sub__(vert2)
        else:
            return Vertex(self.x - other, self.y - other, self.z - other, self.r, self.g, self.b)

    def __rsub__(self, other):
        &#34;&#34;&#34;Subtract other from self only considering positional data&#34;&#34;&#34;
        return self.__sub__(other)

    def __mul__(self, other):
        &#34;&#34;&#34;Multiply self by other only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x * other.x, self.y * other.y, self.z * other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other, default=1.0)
            return self.__mul__(vert2)
        else:
            return Vertex(self.x * other, self.y * other, self.z * other, self.r, self.g, self.b)

    def __rmul__(self, other):
        &#34;&#34;&#34;Multiply self by other only considering positional data&#34;&#34;&#34;
        return self.__mul__(other)

    def __div__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return Vertex(self.x / other.x, self.y / other.y, self.z / other.z, self.r, self.g, self.b)
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex and call again
            vert2 = Vertex(other, default=1.0)
            return self.__div__(vert2)
        else:
            return Vertex(self.x / other, self.y / other, self.z / other, self.r, self.g, self.b)

    def __rdiv__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        return self.__div__(other)

    # true div use div for now
    def __truediv__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        return self.__div__(other)

    def __rtruediv__(self, other):
        &#34;&#34;&#34;Divide self by other only considering positional data&#34;&#34;&#34;
        return self.__rdiv__(other)


    # Define comparison operators
    def __eq__(self, other):
        &#34;&#34;&#34;Equality operator for only positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return self.x == other.x and self.y == other.y and self.z == other.z
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex call again
            vert2 = Vertex(other)
            return self.__eq__(vert2)
        else:
            return self.x == other and self.y == other and self.z == other

    # Less then and greater then operators based on magnitude
    def __lt__(self, other):
        &#34;&#34;&#34;Less than operator for only positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return self.magnitude() &lt; other.magnitude()
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex call again
            vert2 = Vertex(other)
            return self.__lt__(vert2)
        else:
            return self.magnitude() &lt; other

    def __gt__(self, other):
        &#34;&#34;&#34;Greater than operator for only positional data&#34;&#34;&#34;
        if isinstance(other, Vertex):
            return self.magnitude() &gt; other.magnitude()
        elif isinstance(other, (Sequence, np.ndarray)):
            # Convert other to vertex call again
            vert2 = Vertex(other)
            return self.__gt__(vert2)
        else:
            return self.magnitude() &gt; other

    def __le__(self, other):
        return self.__lt__(other) or self.__eq__(other)

    def __ge__(self, other):
        return self.__gt__(other) or self.__eq__(other)

    def __repr__(self):
        return f&#39;Vertex({self.x}, {self.y}, {self.z}, {self.r}, {self.g}, {self.b})&#39;

    # TODO add __str__</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pygline.common.Vertex.one"><code class="name">var <span class="ident">one</span></code></dt>
<dd>
<div class="desc"><p>1.0 as a numpy float32</p></div>
</dd>
<dt id="pygline.common.Vertex.variables"><code class="name">var <span class="ident">variables</span></code></dt>
<dd>
<div class="desc"><p>All the variable a Vertex should hold, like <strong>dict</strong> but as string</p></div>
</dd>
<dt id="pygline.common.Vertex.zero"><code class="name">var <span class="ident">zero</span></code></dt>
<dd>
<div class="desc"><p>0.0 as a numpy float32</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pygline.common.Vertex.b"><code class="name">var <span class="ident">b</span></code></dt>
<dd>
<div class="desc"><p>Blue value as a float</p></div>
</dd>
<dt id="pygline.common.Vertex.g"><code class="name">var <span class="ident">g</span></code></dt>
<dd>
<div class="desc"><p>Green value as a float</p></div>
</dd>
<dt id="pygline.common.Vertex.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<div class="desc"><p>Red value as a float</p></div>
</dd>
<dt id="pygline.common.Vertex.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>X postion as a float</p></div>
</dd>
<dt id="pygline.common.Vertex.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>Y postion as a float</p></div>
</dd>
<dt id="pygline.common.Vertex.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<div class="desc"><p>Z postion as a flo
at</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygline.common.Vertex.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retuns a copy of the vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Retuns a copy of the vertex&#34;&#34;&#34;
    return Vertex(self.x, self.y, self.z, self.r, self.g, self.b)</code></pre>
</details>
</dd>
<dt id="pygline.common.Vertex.get_brightness"><code class="name flex">
<span>def <span class="ident">get_brightness</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the brightness of the vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_brightness(self):
    &#34;&#34;&#34;Returns the brightness of the vertex&#34;&#34;&#34;
    return np.sqrt(self.r**2 + self.g**2 + self.b**2)</code></pre>
</details>
</dd>
<dt id="pygline.common.Vertex.get_magnitude"><code class="name flex">
<span>def <span class="ident">get_magnitude</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the magnitude of the vertex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_magnitude(self):
    &#34;&#34;&#34;Returns the magnitude of the vertex&#34;&#34;&#34;
    return np.sqrt(self.x**2 + self.y**2 + self.z**2)</code></pre>
</details>
</dd>
<dt id="pygline.common.Vertex.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes the vertex to a unit vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self):
    &#34;&#34;&#34;Normalizes the vertex to a unit vector&#34;&#34;&#34;
    mag = self.magnitude()
    if mag != 0.0:
        self.x /= mag
        self.y /= mag
        self.z /= mag</code></pre>
</details>
</dd>
<dt id="pygline.common.Vertex.normalize_color"><code class="name flex">
<span>def <span class="ident">normalize_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize the color to a unit vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_color(self):
    &#34;&#34;&#34;Normalize the color to a unit vector&#34;&#34;&#34;
    mag = self.brightness()
    if mag != 0.0:
        self.r /= mag
        self.g /= mag
        self.b /= mag</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygline" href="index.html">pygline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygline.common.Vertex" href="#pygline.common.Vertex">Vertex</a></code></h4>
<ul class="two-column">
<li><code><a title="pygline.common.Vertex.b" href="#pygline.common.Vertex.b">b</a></code></li>
<li><code><a title="pygline.common.Vertex.copy" href="#pygline.common.Vertex.copy">copy</a></code></li>
<li><code><a title="pygline.common.Vertex.g" href="#pygline.common.Vertex.g">g</a></code></li>
<li><code><a title="pygline.common.Vertex.get_brightness" href="#pygline.common.Vertex.get_brightness">get_brightness</a></code></li>
<li><code><a title="pygline.common.Vertex.get_magnitude" href="#pygline.common.Vertex.get_magnitude">get_magnitude</a></code></li>
<li><code><a title="pygline.common.Vertex.normalize" href="#pygline.common.Vertex.normalize">normalize</a></code></li>
<li><code><a title="pygline.common.Vertex.normalize_color" href="#pygline.common.Vertex.normalize_color">normalize_color</a></code></li>
<li><code><a title="pygline.common.Vertex.one" href="#pygline.common.Vertex.one">one</a></code></li>
<li><code><a title="pygline.common.Vertex.r" href="#pygline.common.Vertex.r">r</a></code></li>
<li><code><a title="pygline.common.Vertex.variables" href="#pygline.common.Vertex.variables">variables</a></code></li>
<li><code><a title="pygline.common.Vertex.x" href="#pygline.common.Vertex.x">x</a></code></li>
<li><code><a title="pygline.common.Vertex.y" href="#pygline.common.Vertex.y">y</a></code></li>
<li><code><a title="pygline.common.Vertex.z" href="#pygline.common.Vertex.z">z</a></code></li>
<li><code><a title="pygline.common.Vertex.zero" href="#pygline.common.Vertex.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>